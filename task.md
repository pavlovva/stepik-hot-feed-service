# Тестовое задание на позицию Backend разработчик в Stepik
**Стек:** Django1.11, Python3.7.
**Срок:** 3–5 дней.
**Лимит кода:** ≤ 350 LoC продакшен‑кода (не учитывая тесты и миграции).

> Если информации не хватает, **сделайте разумные предположения**. Коротко зафиксируйте их в задаче. Мы оцениваем ваш ход мыслей и умение определять контекст.

---

## Что мы ожидаем
1) Ссылка на публичный репозиторий с решением **одной задачи** из списка.
2) **Документ с описанием технического дизайна**:
   - Какие предположения вы сделали и почему.
   - Что может пойти не так при масштабе **100×** от текущего?
   - 3 метрики, которые вы бы включили в первый релиз (конкретно: counter names, alert thresholds).
   - Один абзац: «Если это сломается в 3 утра, куда смотреть, чтобы понять, что произошло».
3) **Короткий список «следующих шагов»** (≤ 10 пунктов): что еще добавить перед реальным продакшеном?

---

## Выберите одну задачу

### A) Payment Webhook Ingest (idempotent + fast ACK)
**Сценарий:** Партнёр отправляет платёжные события (`charge.succeeded`, `refund.created`, `dispute.opened`). События могут быть **duplicated** и приходить **out‑of‑order**.

**Реализация:**
- `POST /v1/webhooks/payment`, который:
  - Проверяет HMAC-SHA256‑заголовок, при несовпадении возвращает 401.
  - Сохраняет событие с дедупликацией в БД (`provider_event_id`).
  - Ставит асинхронную обработку в очередь (Celery). **Ответ ≤ 200мс** на валидный запрос.
- Worker, который обрабатывает события идемпотентно:
  - Для `charge.succeeded` помечает заказ оплаченным один раз (никогда дважды).
  - Для `refund.created` создаёт запись возврата только один раз, даже при ретраях.
  - На 429/5xx от downstream применяет экспоненциальный retry с верхней границей попыток.

**Критерии выполнения (должно быть показано в тестах):**
- Валидная подпись: 200; невалидная: 401.
- Дубликат `provider_event_id` не вызывает побочных эффектов.
- `Refund`, пришедший раньше `charge`, обрабатывается детерминированно, т.е. всегда одним и тем же способом (объясните выбор).
- Необязательно: определите p95‑цели для запроса; укажите один‑два счётчика/alert, которые вы бы добавили.

---

### B) Hot Feed with Cache‑Aside & Stampede Guard
**Сценарий:** `GET /v1/feed/hot?limit=50` возвращает топ постов по `score` (например, лайки за последние 24 часа). Нагрузка на чтение - высокая; запись - умеренная.

**Реализация:**
- Модели БД: `Post(id, like_count, created_at)` и `Like(id, post_id, user_id)`.
- Необходимо кэшировать данные. При новом `Like` инвалидируйте или ..?
- Предотвратите thundering herd при отсутствии записи в кэше (простая блокировка, request coalescing или dogpile TTL).

**Критерии выполнения (должно быть показано в тестах):**
- Нет N+1; стабильный порядок; согласованная пагинация.
- Инвалидация обновляет ленту в пределах заданного вами окна.
- Stampede guard обеспечивает единственное обновление при конкурентных промахах.
- Необязательно: объясните логику выбора TTL/границ инвалидации.

---

### C) Fast DAU & 7‑Day Retention from a Large Events Table
**Сценарий:** Нужно посчитать DAU по дням и количество вернувшихся пользователей за последние 7 дней, забирая данные из большой таблице `events`.

**Реализация:**
- Схема: `events(user_id int, course_id int, kind text, performed_at timestamp, properties jsonb)`.
- Напишите SQL (или используйте Django ORM) для получения:
  - Список DAU по дням на выбранном диапазоне дат.
  - Список пользователей, активных в день D и также активных в D‑1..D‑7.
- Предложите конкретные индексы.
- Необязательно: наметьте небольшую **rollup**‑таблицу для снижения затрат.

**Критерии выполнения (должно быть показано в тестах):**
- Корректные результаты на синтетическом наборе данных, созданном вами.
- Схема индексов в DDL соответствует реальным паттернам запросов и предотвращает full scan.
- Необязательно: определите, как балансировать свежесть данных и стоимость обработки (например, daily rollup + hourly delta).

---

## Технические заметки и ограничения
- Используйте `url()` в `urls.py`, `transaction.atomic`, `select_for_update`, `prefetch_related`, `annotate` и т.д.
- Background tasks: реализуйте Celery-задачи (v4-style) и продемонстрируйте корректный retry/backoff.
- Можно использовать SQLite локально, но SQL/индексы пишите с прицелом на PostgreSQL.
